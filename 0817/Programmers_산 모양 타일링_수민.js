/**
 * 문제 풀이 실패.
 * dp 알고리즘 + 1차원 배열 문제인줄 알았다. (테스트7개까지성공하고 나머지 시간초과뜸)
 *
 * dp 상태를 두가지로 분리해서 관리하는 방식을 사용한다고 한다.
 * - dp[i][0] 산을 타일로 채우되 오른쪽 아래 대각선을 사용하지 않는 경우
 * - dp[i][1] 산을 마름모로 채운 경우
 *
 * dp[i][1] = dp[i-1][0] + dp[i-1][1]
 * - 마름모로 채운 경우, i-1번째가 어떤 경우든 상관없이 그대로 이어짐
 *
 * dp[i][0] = (2 + tops[i-1]) * dp[i-1][0] + (1 + tops[i-1]) * dp[i-1][1]
 * - 이전이 [0]인 경우: (기본 2가지 경우 + 탑이 있으면 추가 1가지 경우)
 * - 이전이 [1]인 경우: (기본 1가지 경우 + 탑이 있으면 추가 1가지 경우)
 *
 * 너무 어려운 문제였네요..ㅠ
 */

function solution(n, tops) {
  const MOD = 10007;
  const dp = Array.from({ length: n + 1 }, () => [0, 0]);

  dp[0][0] = 1; // 아무것도 없는 상태에서 시작
  dp[0][1] = 0;

  for (let i = 1; i <= n; i++) {
    const isTop = tops[i - 1]; // 탑 유무
    // 오른쪽 아래 마름모 사용한 경우
    dp[i][1] = (dp[i - 1][0] + dp[i - 1][1]) % MOD;
    // 마름모를 사용하지 않은 경우
    dp[i][0] = ((2 + isTop) * dp[i - 1][0] + (1 + isTop) * dp[i - 1][1]) % MOD;
  }

  return (dp[n][0] + dp[n][1]) % MOD;
}

console.log(solution(4, [1, 1, 0, 1]));
